//! HTTP/SSE MCP bridge for VM-based OpenCode clients.
//!
//! Runs a Streamable HTTP MCP transport on the bridge interface so that
//! OpenCode instances inside workspace VMs can connect back to agentiso
//! as MCP clients. Each connection is authenticated via a workspace-scoped
//! bearer token injected via `set_env`.
//!
//! Token lifecycle:
//! - Generated by `AuthManager::generate_bridge_token()` in `swarm_run`
//! - Injected into VM via `ConfigureMcpBridge` vsock message
//! - Validated on each HTTP request by the auth middleware
//! - Revoked by `AuthManager::revoke_bridge_token()` on cleanup

use std::net::SocketAddr;
use std::sync::Arc;

use axum::Router;
use rmcp::transport::streamable_http_server::{
    StreamableHttpServerConfig, StreamableHttpService,
    session::local::LocalSessionManager,
};
use tracing::{info, warn};
use uuid::Uuid;

use crate::config::{McpBridgeConfig, RateLimitConfig};
use crate::team::TeamManager;
use crate::workspace::WorkspaceManager;

use super::auth::AuthManager;
use super::metrics::MetricsRegistry;
use super::tools::AgentisoServer;
use super::vault;

// ---------------------------------------------------------------------------
// Bridge server
// ---------------------------------------------------------------------------

/// Shared state for constructing per-session AgentisoServer instances.
struct BridgeState {
    workspace_manager: Arc<WorkspaceManager>,
    auth_manager: AuthManager,
    transfer_dir: std::path::PathBuf,
    metrics: Option<MetricsRegistry>,
    vault_manager: Option<Arc<vault::VaultManager>>,
    rate_limit_config: RateLimitConfig,
    team_manager: Option<Arc<TeamManager>>,
    message_relay: Arc<crate::team::MessageRelay>,
}

/// Start the HTTP MCP bridge as a background tokio task.
///
/// The bridge listens on the configured address (typically `10.99.0.1:3100`)
/// and serves the full MCP protocol over Streamable HTTP transport.
///
/// Each connecting client must provide `Authorization: Bearer <token>` where
/// the token was generated by `AuthManager::generate_bridge_token()` and
/// maps to a specific (session_id, workspace_id) pair.
///
/// Per-workspace scoping: each bridge session gets its own `AgentisoServer`
/// with a unique session ID. The workspace is adopted into that session so
/// the existing ownership checks in tool handlers enforce access control.
///
/// Returns a `JoinHandle` for the background listener task.
pub fn start_bridge(
    config: &McpBridgeConfig,
    workspace_manager: Arc<WorkspaceManager>,
    auth_manager: AuthManager,
    transfer_dir: std::path::PathBuf,
    metrics: Option<MetricsRegistry>,
    vault_manager: Option<Arc<vault::VaultManager>>,
    rate_limit_config: RateLimitConfig,
    team_manager: Option<Arc<TeamManager>>,
    message_relay: Arc<crate::team::MessageRelay>,
) -> tokio::task::JoinHandle<()> {
    let addr: SocketAddr = format!("{}:{}", config.bind_addr, config.port)
        .parse()
        .expect("invalid mcp_bridge bind address");

    let state = Arc::new(BridgeState {
        workspace_manager,
        auth_manager,
        transfer_dir,
        metrics,
        vault_manager,
        rate_limit_config,
        team_manager,
        message_relay,
    });

    let streamable_config = StreamableHttpServerConfig {
        stateful_mode: true,
        ..Default::default()
    };

    // The StreamableHttpService creates a new MCP Service for each session.
    // Each bridge session gets a unique session ID and adopts its workspace
    // when the first tool call arrives (via check_ownership).
    //
    // Token auth is enforced by the axum middleware layer below, which
    // validates the bearer token on each request before it reaches the
    // MCP transport layer.
    let state_clone = state.clone();
    let mcp_service: StreamableHttpService<_, LocalSessionManager> = StreamableHttpService::new(
        move || {
            let session_id = format!("bridge-{}", Uuid::new_v4());
            let st = state_clone.clone();

            // Register session in AuthManager so tool calls can track ownership.
            // This is a sync context so we block on the async register call.
            // The session starts empty; workspace ownership is adopted when the
            // connecting OpenCode client makes its first tool call.
            let auth = st.auth_manager.clone();
            let sid = session_id.clone();
            tokio::task::block_in_place(|| {
                tokio::runtime::Handle::current().block_on(async {
                    auth.register_session(sid).await;
                });
            });

            let server = AgentisoServer::with_metrics(
                st.workspace_manager.clone(),
                st.auth_manager.clone(),
                session_id,
                st.transfer_dir.clone(),
                st.metrics.clone(),
                st.vault_manager.clone(),
                st.rate_limit_config.clone(),
                st.team_manager.clone(),
                st.message_relay.clone(),
            );
            Ok(server)
        },
        Arc::new(LocalSessionManager::default()),
        streamable_config,
    );

    // Build axum app with token validation middleware.
    // The middleware checks `Authorization: Bearer <token>` against
    // AuthManager.validate_bridge_token(). Requests without a valid
    // token get a 401 response before reaching the MCP transport.
    let auth_state = state.auth_manager.clone();
    let app = Router::new()
        .route(
            "/mcp",
            axum::routing::any_service(mcp_service),
        )
        .layer(axum::middleware::from_fn(move |req, next| {
            let auth = auth_state.clone();
            bridge_auth_middleware(auth, req, next)
        }));

    tokio::spawn(async move {
        let listener = match tokio::net::TcpListener::bind(addr).await {
            Ok(l) => l,
            Err(e) => {
                warn!(addr = %addr, error = %e, "failed to bind MCP bridge");
                return;
            }
        };
        info!(addr = %addr, "MCP bridge listening");
        if let Err(e) = axum::serve(listener, app).await {
            warn!(error = %e, "MCP bridge server error");
        }
    })
}

/// Axum middleware that validates bearer tokens on bridge requests.
///
/// Extracts `Authorization: Bearer <token>` from the request, validates
/// it against `AuthManager::validate_bridge_token()`, and returns 401
/// if the token is missing or invalid.
async fn bridge_auth_middleware(
    auth: AuthManager,
    req: axum::extract::Request,
    next: axum::middleware::Next,
) -> axum::response::Response {
    use axum::http::StatusCode;
    use axum::response::IntoResponse;

    // Extract bearer token from Authorization header.
    let token = req
        .headers()
        .get(axum::http::header::AUTHORIZATION)
        .and_then(|v| v.to_str().ok())
        .and_then(|v| v.strip_prefix("Bearer "));

    match token {
        Some(token) => {
            // Validate token.
            if auth.validate_bridge_token(token).await.is_some() {
                next.run(req).await
            } else {
                warn!(token_prefix = &token[..token.len().min(8)], "invalid bridge token");
                (StatusCode::UNAUTHORIZED, "Invalid bridge token").into_response()
            }
        }
        None => {
            // No Authorization header â€” return 401.
            (StatusCode::UNAUTHORIZED, "Missing Authorization: Bearer <token>").into_response()
        }
    }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::McpBridgeConfig;
    use crate::mcp::auth::SessionQuota;

    #[test]
    fn test_bridge_config_defaults() {
        let cfg = McpBridgeConfig::default();
        assert!(!cfg.enabled);
        assert_eq!(cfg.bind_addr, "10.99.0.1");
        assert_eq!(cfg.port, 3100);
    }

    #[test]
    fn test_bearer_token_extraction_missing() {
        let req = axum::http::Request::builder()
            .uri("/mcp")
            .body(())
            .unwrap();
        let token = req
            .headers()
            .get(axum::http::header::AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.strip_prefix("Bearer "));
        assert!(token.is_none());
    }

    #[test]
    fn test_bearer_token_extraction_present() {
        let req = axum::http::Request::builder()
            .uri("/mcp")
            .header("Authorization", "Bearer mcp-abc123")
            .body(())
            .unwrap();
        let token = req
            .headers()
            .get(axum::http::header::AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.strip_prefix("Bearer "));
        assert_eq!(token, Some("mcp-abc123"));
    }

    #[test]
    fn test_bearer_token_extraction_wrong_scheme() {
        let req = axum::http::Request::builder()
            .uri("/mcp")
            .header("Authorization", "Basic abc123")
            .body(())
            .unwrap();
        let token = req
            .headers()
            .get(axum::http::header::AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.strip_prefix("Bearer "));
        assert!(token.is_none());
    }

    #[tokio::test]
    async fn test_auth_manager_bridge_token_roundtrip() {
        let auth = AuthManager::new(SessionQuota::default());
        let sid = auth.register_session("test-session".into()).await;
        let ws_id = Uuid::new_v4();

        // Generate a bridge token.
        let token = auth.generate_bridge_token(&sid, ws_id).await;
        assert!(token.starts_with("mcp-"));

        // Validate it.
        let entry = auth.validate_bridge_token(&token).await;
        assert!(entry.is_some());
        let (session_id, workspace_id) = entry.unwrap();
        assert_eq!(session_id, sid);
        assert_eq!(workspace_id, ws_id);

        // Revoke it.
        auth.revoke_bridge_token(&token).await;
        assert!(auth.validate_bridge_token(&token).await.is_none());
    }

    #[tokio::test]
    async fn test_auth_manager_revoke_workspace_tokens() {
        let auth = AuthManager::new(SessionQuota::default());
        let sid = auth.register_session("test-session".into()).await;
        let ws1 = Uuid::new_v4();
        let ws2 = Uuid::new_v4();

        let t1 = auth.generate_bridge_token(&sid, ws1).await;
        let t2 = auth.generate_bridge_token(&sid, ws1).await;
        let t3 = auth.generate_bridge_token(&sid, ws2).await;

        auth.revoke_bridge_tokens_for_workspace(ws1).await;
        assert!(auth.validate_bridge_token(&t1).await.is_none());
        assert!(auth.validate_bridge_token(&t2).await.is_none());
        assert!(auth.validate_bridge_token(&t3).await.is_some());
    }

    #[tokio::test]
    async fn test_unknown_token_rejected() {
        let auth = AuthManager::new(SessionQuota::default());
        assert!(auth.validate_bridge_token("fake-token").await.is_none());
    }

    #[tokio::test]
    async fn test_unique_tokens_per_workspace() {
        let auth = AuthManager::new(SessionQuota::default());
        let sid = auth.register_session("s".into()).await;
        let ws = Uuid::new_v4();
        let t1 = auth.generate_bridge_token(&sid, ws).await;
        let t2 = auth.generate_bridge_token(&sid, ws).await;
        assert_ne!(t1, t2);
    }
}
